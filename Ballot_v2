pragma solidity ^0.4.9;

/// Smart Contract de votacion
///@author drumsjuanma
contract Ballot {


    //Estructura de datos que representa un unico votante
    struct Voter {
        uint weight; // Peso del voto
        bool voted;  // If true, la persona ya ha votado
        address delegate; // Persona a la que se le delega el voto
        uint vote;   // Index de la propuesta votada
    }

    // Estructura de datos que representa una propuesta de la votacion
    struct Proposal
    {
        bytes32 name;   // Nombre de la propuesta (hasta 32 bytes)
        uint voteCount; // Numero de votos acumulados
    }

    // Usuario que controla la votacion (da permisos)
    address public chairperson;

    // Maping entre direcciones de usuarios al struct de Voter
    mapping(address => Voter) public voters;

    // Array dinamica de los nombres de las propuestas
    Proposal[] public proposals;

    /// Crea una nueva votacion con las propuestas pasadas
    function Ballot(bytes32[] proposalNames) {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;

        // Por cada propuesta pasada al constructor se anade una nueva al
        // array de propuestas
        for (uint i = 0; i < proposalNames.length; i++) {
            proposals.push(Proposal({name: proposalNames[i],voteCount: 0}));
        }
    }

    // Da derecho de voto a una direccion 
    // Solo puede ser invocado por el chairperson 
    function giveRightToVote(address voter) {
        if (msg.sender != chairperson || voters[voter].voted) {
            throw;
        }
        voters[voter].weight = 1;
    }



    /// Delega el voto a otra direccion
    function delegate(address to) {
        Voter sender = voters[msg.sender];
        if (sender.voted){
            throw;
        }

        // Delegacion recursiva
        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender) {
            to = voters[to].delegate;
        }

        // Si hay un bucle en la delegacion, error
        if (to == msg.sender) {
            throw;
        }

        // 'Sender' es una referencia a voters[msg.sender]
        sender.voted = true;
        sender.delegate = to;
        Voter delegate = voters[to];
        if (delegate.voted) {
            //Si el delegado ya ha votado, se suman los votos a la propuesta
            proposals[delegate.vote].voteCount += sender.weight;
        } else {
            // Si el delegado no ha votado, se le anade un voto al peso
            delegate.weight += sender.weight;
        }
    }

    /// Funcion para votar la propuesta dada su indice en el aray
    function vote(uint proposal) {
        Voter sender = voters[msg.sender];
        if (sender.voted){
            throw;
        }
        sender.voted = true;
        sender.vote = proposal;

        // Si la propuesta esta fuera de rango se desacen los cambios automaticamente
        proposals[proposal].voteCount += sender.weight;
    }

    /// Devuelve el indice de la propuesta ganadora
    function winningProposal() constant returns (uint winningProposal){
        uint winningVoteCount = 0;
        for (uint p = 0; p < proposals.length; p++) {
            if (proposals[p].voteCount > winningVoteCount) {
                winningVoteCount = proposals[p].voteCount;
                winningProposal = p;
            }
        }
    }

    // Devuelve el nombre de la propuesta ganadora
    function winnerName() constant returns (bytes32 winnerName){
        winnerName = proposals[winningProposal()].name;
    }
}       